//Name: Carmen Lau
//Student ID: 166689216
//Email: clau51@myseneca.ca
//Date: January 16, 2022
//Section: NDD
//I have done all the coding by myself and only copied the code that my professor provided to complete my workshops and assignments.

Having completed this workshop, I was able to clarify the differences between internal and external linkages through the use of the static and extern keywords. External linkage occurs when an entity, possibly a variable or a function, is declared within a different scope within another translation unit, while internal linkage occurs when an entity is invisible outside its own translation unit, but visible to other scopes within its translation unit. The keyword that identifies external linkage is "extern". In our workshop, we encountered two global variables named "g_taxrate" and "g_dailydiscount" which were used across two different implementation files (w1_p2.cpp and foodorder.cpp). As each implementation file is considered a separate translation unit, we could use the "extern" keyword to indicate that "g_taxrate" and "g_dailydiscount" have an external linkage, telling the compiler that these variables are defined somewhere else. By making these two variables extern in the header file, I was able to allow both implementation files to have access to the two variables since w1_p2.cpp would include the "foodorder.h" header file. On the other hand, the two variables were instantiated in the "foodorder.cpp" implementation file, setting it to a safe empty state of 0.0. As a result of externally linking these variables, this makes it possible to assign different values to the "g_taxrate" and "g_dailydiscount" variables in either "w1_p2.cpp" or "foodorder.cpp" and any changes will refer to the same variables (that is, each variable will have same memory address). In our case, we assigned "g_taxrate" and "g_dailydiscount" values of 0.13 and 1.15 for the first day, respectively, and 0.14 and 1.15 for any other day. If we were to print or use either variables in the "foodorder.cpp" file, 0.13 and 1.15, or 0.14 and 1.15 would be printed or used since they are the same variables referring to the same memory address.  

On the other hand, internal linkage was used through the "static" keyword. In our workshop, we used a "counter" variable that was declared with the "static" keyword. This means that the counter has internal linkage and will not be accessible by anything outside of this scope and translation unit, while retaining its value within this translation unit until the program ends. This is helpful as the counter will not be reinitialized every time and can not be manually updated in the "w1_p2.cpp" file, and will only be updated if the display() function is called (since the counter is only updated when the display function is called), allowing the scope to be reduced, preventing errors and improving modularity. 

Between part 1 and part 2, I had to make m_description dynamically allocated and hence, I had to manually deallocate memory that was previously allocated to m_description. We were instructed to try out some std::string related functions, so in my read function, I used the std::getline function instead of the istream::getline() method. Since I created a temporary string called description, I was also able to use the std::string::length function instead of strlen() to find the length of the description. Additionally, whenever I set the object to an empty state by using the setEmpty() method, I had to make sure that I used the delete[] operator to deallocate memory that was previously allocated to m_description since my setEmpty() function sets m_description to nullptr. If I set m_description to nullptr without first deleting the allocated memory, I would have a memory leak. In part 1, nothing was dynamically allocated, hence, I did not have to worry about shallow copying, deep copying, and following the rule of three. However, because in part 2, we were dealing with some kind of dynamic memory, I had to make sure that objects were being properly copied over and memory were to be properly deallocated. Hence, I had to create a destructor and apply the rule of three. In "w1_p2.cpp", a copy constructor should be called where "sdds::FoodOrder copy = currentOrder". However, if a copy constructor did not exist, shallow copying would occur, which is not what we want since m_description must be deep copied. As a result, I also had to create a copy constructor, copy assignment, and a destructor in part 2.

